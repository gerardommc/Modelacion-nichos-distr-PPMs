<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title> 5 Unidad II - Utilizando spatstat | Modelación de nichos ecológicos y aŕeas de distribución con MPPs</title>
  <meta name="description" content="Sitio del curso de Modelado de nichos ecológicos | Posgrado de Ciencias Biológicas" />
  <meta name="generator" content="bookdown 0.27 and GitBook 2.6.7" />

  <meta property="og:title" content=" 5 Unidad II - Utilizando spatstat | Modelación de nichos ecológicos y aŕeas de distribución con MPPs" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="Sitio del curso de Modelado de nichos ecológicos | Posgrado de Ciencias Biológicas" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content=" 5 Unidad II - Utilizando spatstat | Modelación de nichos ecológicos y aŕeas de distribución con MPPs" />
  
  <meta name="twitter:description" content="Sitio del curso de Modelado de nichos ecológicos | Posgrado de Ciencias Biológicas" />
  

<meta name="author" content="Gerardo Martín" />


<meta name="date" content="2022-11-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"/>
<link rel="next" href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Modelación de nichos ecológicos y distribuciones con MPPs I</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Preámbulo</a></li>
<li class="chapter" data-level="2" data-path="encuadre-de-la-materia.html"><a href="encuadre-de-la-materia.html"><i class="fa fa-check"></i><b>2</b> Encuadre de la materia</a>
<ul>
<li class="chapter" data-level="2.1" data-path="encuadre-de-la-materia.html"><a href="encuadre-de-la-materia.html#criterios-de-evaluación"><i class="fa fa-check"></i><b>2.1</b> Criterios de evaluación</a></li>
<li class="chapter" data-level="2.2" data-path="encuadre-de-la-materia.html"><a href="encuadre-de-la-materia.html#cómo-se-darán-las-clases"><i class="fa fa-check"></i><b>2.2</b> ¿Cómo se darán las clases?</a></li>
<li class="chapter" data-level="2.3" data-path="encuadre-de-la-materia.html"><a href="encuadre-de-la-materia.html#contacto"><i class="fa fa-check"></i><b>2.3</b> Contacto</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><i class="fa fa-check"></i><b>3</b> Unidad I: Introducción al modelado de nichos ecológicos</a>
<ul>
<li class="chapter" data-level="3.1" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#introducción-al-modelado-de-nichos-ecológicos"><i class="fa fa-check"></i><b>3.1</b> Introducción al modelado de nichos ecológicos</a></li>
<li class="chapter" data-level="3.2" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#insumos-para-el-modelado-correlativo-de-nichos-ecológicos"><i class="fa fa-check"></i><b>3.2</b> Insumos para el modelado correlativo de nichos ecológicos</a></li>
<li class="chapter" data-level="3.3" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#el-proceso-de-calibración"><i class="fa fa-check"></i><b>3.3</b> El proceso de calibración</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#tutorial-de-r"><i class="fa fa-check"></i><b>3.3.1</b> Tutorial de <strong>R</strong></a></li>
<li class="chapter" data-level="3.3.2" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#calibración-de-modelos-de-nicho-ecológico"><i class="fa fa-check"></i><b>3.3.2</b> Calibración de modelos de nicho ecológico</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#uso-de-r-como-sistema-de-información-geográfica"><i class="fa fa-check"></i><b>3.4</b> Uso de R como Sistema de Información Geográfica</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html"><a href="unidad-i-introducción-al-modelado-de-nichos-ecológicos.html#lectura-de-capas-raster"><i class="fa fa-check"></i><b>3.4.1</b> Lectura de capas raster</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><i class="fa fa-check"></i><b>4</b> Unidad II: Modelación de nichos ecológicos con procesos de puntos</a>
<ul>
<li class="chapter" data-level="4.1" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html#introducción"><i class="fa fa-check"></i><b>4.1</b> Introducción</a></li>
<li class="chapter" data-level="4.2" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html#formateo-de-datos"><i class="fa fa-check"></i><b>4.2</b> Formateo de datos</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html#formateo-de-datos-raster"><i class="fa fa-check"></i><b>4.2.1</b> Formateo de datos raster</a></li>
<li class="chapter" data-level="4.2.2" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html#obteniendo-la-ventana-de-trabajo"><i class="fa fa-check"></i><b>4.2.2</b> Obteniendo la ventana de trabajo</a></li>
<li class="chapter" data-level="4.2.3" data-path="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html"><a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html#formateando-los-registros-de-ocurrencia"><i class="fa fa-check"></i><b>4.2.3</b> Formateando los registros de ocurrencia</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html"><i class="fa fa-check"></i><b>5</b> Unidad II - Utilizando <code>spatstat</code></a>
<ul>
<li class="chapter" data-level="5.1" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#análisis-exploratorio"><i class="fa fa-check"></i><b>5.1</b> Análisis exploratorio</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#independencia-y-autocorrelación"><i class="fa fa-check"></i><b>5.1.1</b> Independencia y autocorrelación</a></li>
<li class="chapter" data-level="5.1.2" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#análisis-gráfico-de-las-respuestas-al-medio-ambiente."><i class="fa fa-check"></i><b>5.1.2</b> Análisis gráfico de las respuestas al medio ambiente.</a></li>
<li class="chapter" data-level="5.1.3" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#midiendo-la-correlación-entre-variables-independientes"><i class="fa fa-check"></i><b>5.1.3</b> Midiendo la correlación entre variables independientes</a></li>
<li class="chapter" data-level="5.1.4" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#propuesta-de-modelos-alternativos"><i class="fa fa-check"></i><b>5.1.4</b> Propuesta de modelos alternativos</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#ajustando-un-proceso-de-puntos"><i class="fa fa-check"></i><b>5.2</b> Ajustando un proceso de puntos</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#selección-del-modelo"><i class="fa fa-check"></i><b>5.2.1</b> Selección del modelo</a></li>
<li class="chapter" data-level="5.2.2" data-path="unidad-ii---utilizando-spatstat.html"><a href="unidad-ii---utilizando-spatstat.html#verificación-de-supuestos-de-independencia"><i class="fa fa-check"></i><b>5.2.2</b> Verificación de supuestos de independencia</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"><a href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"><i class="fa fa-check"></i><b>6</b> Unidad IV: Modelos para procesos de puntos con estructura espacial</a>
<ul>
<li class="chapter" data-level="6.1" data-path="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"><a href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html#tipos-de-estructura-espacial"><i class="fa fa-check"></i><b>6.1</b> Tipos de estructura espacial</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"><a href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html#modelos-de-interacción-de-puntos"><i class="fa fa-check"></i><b>6.1.1</b> Modelos de interacción de puntos</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html"><a href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html#modelos-para-los-diferentes-tipos-de-estructura"><i class="fa fa-check"></i><b>6.2</b> Modelos para los diferentes tipos de estructura</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><i class="fa fa-check"></i><b>7</b> Unidad V: El desarrollo de un modelo de nicho o de distribución</a>
<ul>
<li class="chapter" data-level="7.1" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html#selección-de-proyección-geográfica"><i class="fa fa-check"></i><b>7.1</b> Selección de proyección geográfica</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html#transformando-los-sistemas-de-coordenadas-en-r"><i class="fa fa-check"></i><b>7.1.1</b> Transformando los sistemas de coordenadas en R</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html#selección-de-variables-ambientales"><i class="fa fa-check"></i><b>7.2</b> Selección de variables ambientales</a></li>
<li class="chapter" data-level="7.3" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html#validación-del-modelo"><i class="fa fa-check"></i><b>7.3</b> Validación del modelo</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html"><a href="unidad-v-el-desarrollo-de-un-modelo-de-nicho-o-de-distribución.html#pruebas-de-validación-estadística"><i class="fa fa-check"></i><b>7.3.1</b> Pruebas de validación estadística</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://gerardommc.github.io" target="blank">Regresar al labo</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Modelación de nichos ecológicos y aŕeas de distribución con MPPs</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="unidad-ii---utilizando-spatstat" class="section level1 hasAnchor" number="5">
<h1><span class="header-section-number"> 5</span> Unidad II - Utilizando <code>spatstat</code><a href="unidad-ii---utilizando-spatstat.html#unidad-ii---utilizando-spatstat" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="análisis-exploratorio" class="section level2 hasAnchor" number="5.1">
<h2><span class="header-section-number">5.1</span> Análisis exploratorio<a href="unidad-ii---utilizando-spatstat.html#análisis-exploratorio" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Antes de proponer un modelo para los datos de ocurrencia, es buena práctica realizar un análisis exploratorio. En realidad, el modelo que propongamos dependerá en buena medida de este análisis exploratorio. Los análisis exploratorios que yo hago comprenden una serie de pasos:</p>
<ol style="list-style-type: decimal">
<li>Probar si los datos de ocurrencia cumplen son independientes unos de otros o si están autocorrelacionados</li>
<li>Ver la respuesta de la intensidad de puntos ante las diferentes variables ambientales que queremos incorporar en el modelo</li>
<li>Medir la correlación entre las diferentes variables</li>
<li>Con base en los puntos 2 y 3 proponer un conjunto de modelos alternativos (más sobre este punto abajo)</li>
</ol>
<div id="independencia-y-autocorrelación" class="section level3 hasAnchor" number="5.1.1">
<h3><span class="header-section-number">5.1.1</span> Independencia y autocorrelación<a href="unidad-ii---utilizando-spatstat.html#independencia-y-autocorrelación" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Se dice que los diferentes puntos son independientes entre sí, si el número de vecinos promedio de cada punto como función de la distancia, sigue una distribución Poisson (figura <a href="unidad-ii---utilizando-spatstat.html#fig:Cuenta-vecinos">5.1</a>). Con esto en mente hay varios escenarios posibles, que en promedio cada punto tenga más vecinos de lo esperado o que tenga menos. En el primer caso, se dice que los puntos están agregados, pues un punto tiende a atraer a otros. En el segundo, los puntos están segregados, o sea que un punto tiende a mantener a otros puntos lejos de sí. El primer caso, de independencia, suele ocurrir cuando los puntos están distribuidos aleatoriamente (figura <a href="unidad-ii---utilizando-spatstat.html#fig:Segreg-agreg">5.2</a>).</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Cuenta-vecinos"></span>
<img src="Unidad-III/Cuenta-vecinos.png" alt="Número de vecinos como función de la distancia en un proceso de puntos." width="412" />
<p class="caption">
Figura 5.1: Número de vecinos como función de la distancia en un proceso de puntos.
</p>
</div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Segreg-agreg"></span>
<img src="Unidad-III/Ejemplo-procesos.png" alt="Ejemplo de procesos de puntos de izquierda a derecha: segregado, aleatorio y agregado (reproducido de Baddeley y Rubak 2016)" width="1069" />
<p class="caption">
Figura 5.2: Ejemplo de procesos de puntos de izquierda a derecha: segregado, aleatorio y agregado (reproducido de Baddeley y Rubak 2016)
</p>
</div>
<p>Existe una serie de pruebas gráficas y estadísticas para medir autocorrelación. Aquí nos enfocaremos en el uso de la prueba de envolturas <em>K</em> de Ripley. La implementación de esta prueba en <code>spatstat</code> genera unos intervalos de confianza alrededor de la expectativa del número de vecinos por medio de simulación. La figura <a href="unidad-ii---utilizando-spatstat.html#fig:K-env">5.3</a> muestra los tres escenarios de segregación, aleatorio y agrecación.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:K-env"></span>
<img src="Unidad-III/K-Ripley.png" alt="Gráfica de la prueba *K* de Ripley implementada en `spatstat`. De izquierda a derecha: funciones de Ripley para puntos segregados, aleatorios y agregados." width="870" />
<p class="caption">
Figura 5.3: Gráfica de la prueba <em>K</em> de Ripley implementada en <code>spatstat</code>. De izquierda a derecha: funciones de Ripley para puntos segregados, aleatorios y agregados.
</p>
</div>
<div id="análisis-de-autocorrelación-en-r-con-spatstat" class="section level4 hasAnchor" number="5.1.1.1">
<h4><span class="header-section-number">5.1.1.1</span> Análisis de autocorrelación en <strong>R</strong> con <code>spatstat</code><a href="unidad-ii---utilizando-spatstat.html#análisis-de-autocorrelación-en-r-con-spatstat" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Haremos este análisis de autocorrelación con el mismo proceso de puntos que formateamos anteriormente. La función de <code>spatstat</code> para la prueba de Ripley es <code>envelope</code>, y los argumentos que requiere son 1) el proceso de puntos a analizar, 2) la función con que se medirá autocorrelación (<code>Kest</code> para <span class="math inline">\(K\)</span> de Ripley) y 3) el número de simulaciones. Normalmente, para un nivel de significancia <span class="math inline">\(P=0.05\)</span>, se utilizan 39 simulaciones, el cual deberá aumentar si el umbral de significancia buscado es más estricto (<span class="math inline">\(P = 0.01\)</span>, p. ej.).</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="unidad-ii---utilizando-spatstat.html#cb52-1" aria-hidden="true" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="fu">envelope</span>(puntos.ppp, <span class="at">fun =</span> Kest, <span class="at">nsim =</span> <span class="dv">39</span>)</span></code></pre></div>
<pre><code>## Generating 39 simulations of CSR  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.
## 
## Done.</code></pre>
<p>Mientras la función corre, <strong>R</strong> imprime la última simulación completada, y el objeto que se obtiene puede graficarse con el método por defecto <code>plot</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="unidad-ii---utilizando-spatstat.html#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(K)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:unnamed-chunk-55"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/unnamed-chunk-55-1.png" alt="Gráfica de la función *K* de Ripley para el proceso de puntos analizado. Las sombras en gris muestran los intervalos de confianza al 95%. La línea roja a guiones representa la expectativa teórica (*K* teórica) en caso de que el proceso de puntos sea aleatorio, y la línea negra sólida es la función de Ripley para el proceso de puntos (la *K* observada). El eje de las *x* representa distancia (en grados) y las *y* el número promedio de vecinos de cada punto." width="576" />
<p class="caption">
Figura 5.4: Gráfica de la función <em>K</em> de Ripley para el proceso de puntos analizado. Las sombras en gris muestran los intervalos de confianza al 95%. La línea roja a guiones representa la expectativa teórica (<em>K</em> teórica) en caso de que el proceso de puntos sea aleatorio, y la línea negra sólida es la función de Ripley para el proceso de puntos (la <em>K</em> observada). El eje de las <em>x</em> representa distancia (en grados) y las <em>y</em> el número promedio de vecinos de cada punto.
</p>
</div>
</div>
</div>
<div id="análisis-gráfico-de-las-respuestas-al-medio-ambiente." class="section level3 hasAnchor" number="5.1.2">
<h3><span class="header-section-number">5.1.2</span> Análisis gráfico de las respuestas al medio ambiente.<a href="unidad-ii---utilizando-spatstat.html#análisis-gráfico-de-las-respuestas-al-medio-ambiente." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Para este análisis simularé una base de datos de ocurrencia donde la probabilidad de observarlos sea inversamente proporcional a la distancia de una centroide pre definido. Con base en ello, podremos ver cómo cambia la intensidad de puntos en realción a los diferentes valores de cada variable.</p>
<div id="simulación-de-datos-de-presencia" class="section level4 hasAnchor" number="5.1.2.1">
<h4><span class="header-section-number">5.1.2.1</span> Simulación de datos de presencia<a href="unidad-ii---utilizando-spatstat.html#simulación-de-datos-de-presencia" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Utilizaré las mismas variables que para el ejercicio anterior de formateo, y el centroide estará localizado en la media aritmética de cada capa:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="unidad-ii---utilizando-spatstat.html#cb55-1" aria-hidden="true" tabindex="-1"></a>centroide <span class="ot">&lt;-</span> <span class="fu">cellStats</span>(s, mean)</span></code></pre></div>
<p>Para calcular la distancia al centroide, necesitamos la covarianza entre las diferentes capas, de modo que la calculamos con la función <code>cov</code>. Hay implementaciones más robustas en el paquete <code>MASS</code>, para nuestros propósitos pedagógicos <code>cov</code> es suficiente. Comenzamos entonces, transformando el stack en una tabla:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="unidad-ii---utilizando-spatstat.html#cb56-1" aria-hidden="true" tabindex="-1"></a>s.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="fu">rasterToPoints</span>(s))</span>
<span id="cb56-2"><a href="unidad-ii---utilizando-spatstat.html#cb56-2" aria-hidden="true" tabindex="-1"></a>covar <span class="ot">&lt;-</span> <span class="fu">cov</span>(s.df[, <span class="dv">3</span><span class="sc">:</span><span class="dv">5</span>])</span></code></pre></div>
<p>Posteriormente, utilizando el centroide y la matriz de covarianza, generamos las distancias utilizando las tres columnas del objeto <code>s.df</code> que contienen los valores de las variables ambientales:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="unidad-ii---utilizando-spatstat.html#cb57-1" aria-hidden="true" tabindex="-1"></a>md <span class="ot">&lt;-</span> <span class="fu">mahalanobis</span>(s.df[, <span class="dv">3</span><span class="sc">:</span><span class="dv">5</span>], <span class="at">center =</span> centroide, <span class="at">cov =</span> covar)</span></code></pre></div>
<p>Y transformamos las distancias al centroide en una capa raster:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="unidad-ii---utilizando-spatstat.html#cb58-1" aria-hidden="true" tabindex="-1"></a>md.r <span class="ot">&lt;-</span> <span class="fu">rasterFromXYZ</span>(<span class="fu">data.frame</span>(s.df[, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>], md))</span>
<span id="cb58-2"><a href="unidad-ii---utilizando-spatstat.html#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(md.r)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Distancia"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/Distancia-1.png" alt="Distancia Mahalanobis al centroide de las capas." width="480" />
<p class="caption">
Figura 5.5: Distancia Mahalanobis al centroide de las capas.
</p>
</div>
<p>Para simular las ocurrencias, transformaré la capa de distancias exponencialmente, para obtener una superficie probabilística:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="unidad-ii---utilizando-spatstat.html#cb59-1" aria-hidden="true" tabindex="-1"></a>md.exp <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="fl">0.5</span><span class="sc">*</span>md.r)</span>
<span id="cb59-2"><a href="unidad-ii---utilizando-spatstat.html#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(md.exp)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Favorabilidad"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/Favorabilidad-1.png" alt="Distancia Mahalanobis transformada exponencialmente para simular presencias. Verde indica mayor probabilidad de ocurrencia." width="480" />
<p class="caption">
Figura 5.6: Distancia Mahalanobis transformada exponencialmente para simular presencias. Verde indica mayor probabilidad de ocurrencia.
</p>
</div>
<p>Para simular las presencias usaré el mismo método que anteriormente, pero en esta ocasión la probabilidad determinará las celdas en que habrá puntos:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="unidad-ii---utilizando-spatstat.html#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">182</span>)</span>
<span id="cb60-2"><a href="unidad-ii---utilizando-spatstat.html#cb60-2" aria-hidden="true" tabindex="-1"></a>puntos<span class="fl">.2</span> <span class="ot">&lt;-</span> dismo<span class="sc">::</span><span class="fu">randomPoints</span>(<span class="at">mask =</span> md.exp,</span>
<span id="cb60-3"><a href="unidad-ii---utilizando-spatstat.html#cb60-3" aria-hidden="true" tabindex="-1"></a>                                <span class="at">n =</span> <span class="dv">200</span>,</span>
<span id="cb60-4"><a href="unidad-ii---utilizando-spatstat.html#cb60-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">prob =</span> T)</span></code></pre></div>
<pre><code>## Warning in .couldBeLonLat(x, warnings = warnings): CRS is NA. Assuming it is
## longitude/latitude</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="unidad-ii---utilizando-spatstat.html#cb62-1" aria-hidden="true" tabindex="-1"></a>puntos<span class="fl">.2</span> <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(puntos<span class="fl">.2</span>)</span>
<span id="cb62-2"><a href="unidad-ii---utilizando-spatstat.html#cb62-2" aria-hidden="true" tabindex="-1"></a>puntos<span class="fl">.2</span><span class="sc">$</span>x <span class="ot">&lt;-</span> puntos<span class="fl">.2</span><span class="sc">$</span>x <span class="sc">+</span> <span class="fu">rnorm</span>(<span class="dv">200</span>, <span class="dv">0</span>, <span class="fl">0.05</span>)</span>
<span id="cb62-3"><a href="unidad-ii---utilizando-spatstat.html#cb62-3" aria-hidden="true" tabindex="-1"></a>puntos<span class="fl">.2</span><span class="sc">$</span>y <span class="ot">&lt;-</span> puntos<span class="fl">.2</span><span class="sc">$</span>y <span class="sc">+</span> <span class="fu">rnorm</span>(<span class="dv">200</span>, <span class="dv">0</span>, <span class="fl">0.05</span>)</span>
<span id="cb62-4"><a href="unidad-ii---utilizando-spatstat.html#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="unidad-ii---utilizando-spatstat.html#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(md.exp); <span class="fu">points</span>(puntos<span class="fl">.2</span>)</span></code></pre></div>
<p><img src="Mod-nich-distr-MPPs_files/figure-html/puntos-1.png" width="672" />
#### Graficación y análisis de las respuestas</p>
<p>Para continuar con el análisis, necesitamos formatear el objeto <code>puntos.2</code> como <code>ppp</code>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="unidad-ii---utilizando-spatstat.html#cb63-1" aria-hidden="true" tabindex="-1"></a>puntos.<span class="fl">2.</span>ppp <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> puntos<span class="fl">.2</span><span class="sc">$</span>x,</span>
<span id="cb63-2"><a href="unidad-ii---utilizando-spatstat.html#cb63-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">y =</span> puntos<span class="fl">.2</span><span class="sc">$</span>y,</span>
<span id="cb63-3"><a href="unidad-ii---utilizando-spatstat.html#cb63-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">window =</span> win,</span>
<span id="cb63-4"><a href="unidad-ii---utilizando-spatstat.html#cb63-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">check =</span> F)</span></code></pre></div>
<p>Recordemos que el objeto <code>win</code> lo generamos en la sección de formateo de este tutorial. Para el análisis de las respuestas necesitamos crear otro objeto, que contiene los conteos de cuadratura, es decir, cuántas presencias por unidad espacial, con la función <code>pixelquad</code> que requiere de dos argumentos, el proceso planar de puntos y la ventana de trabajo en formato <code>owin</code>:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="unidad-ii---utilizando-spatstat.html#cb64-1" aria-hidden="true" tabindex="-1"></a>Q <span class="ot">&lt;-</span> <span class="fu">pixelquad</span>(<span class="at">X =</span> puntos.<span class="fl">2.</span>ppp, <span class="at">W =</span> <span class="fu">as.owin</span>(win))</span></code></pre></div>
<p>Dado que las capas ya están también formateadas como <code>im</code>, podemos ahora sí continuar con el análisis de las respuestas con la función <code>plotQuantIntens</code>. Esta función generará unos gráficos en pdf que deberemos revisar después de correrla. Para cargar la función, haremos igual que con las anteriores. Puedes descargar la función <a href="Funciones-spatstat/plotQuantIntens.R">aquí</a>. Esta función requiere de varios argumentos:</p>
<ol style="list-style-type: decimal">
<li>La lista de imágenes que se usarán para ver cómo cambia la intensidad de puntos en relación a cada variable</li>
<li>El número de cuantiles en que se cortará cada variable para representar la intensidad en el espacio</li>
<li>El objeto de cuadratura (<code>Q</code>)</li>
<li>El objeto con los puntos en formato <code>ppp</code></li>
<li>El nombre del directorio donde se guardará el archivo pdf</li>
<li>El nombre del archivo</li>
</ol>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="unidad-ii---utilizando-spatstat.html#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">&quot;../Funciones-spatstat/plotQuantIntens.R&quot;</span>)</span>
<span id="cb65-2"><a href="unidad-ii---utilizando-spatstat.html#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="unidad-ii---utilizando-spatstat.html#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plotQuantIntens</span>(<span class="at">imList =</span> s.im,</span>
<span id="cb65-4"><a href="unidad-ii---utilizando-spatstat.html#cb65-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">noCuts =</span> <span class="dv">5</span>,</span>
<span id="cb65-5"><a href="unidad-ii---utilizando-spatstat.html#cb65-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">Quad =</span> Q,</span>
<span id="cb65-6"><a href="unidad-ii---utilizando-spatstat.html#cb65-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">p.pp =</span> puntos.<span class="fl">2.</span>ppp,</span>
<span id="cb65-7"><a href="unidad-ii---utilizando-spatstat.html#cb65-7" aria-hidden="true" tabindex="-1"></a>                <span class="at">dir =</span> <span class="st">&quot;&quot;</span>,</span>
<span id="cb65-8"><a href="unidad-ii---utilizando-spatstat.html#cb65-8" aria-hidden="true" tabindex="-1"></a>                <span class="at">name =</span> <span class="st">&quot;Responses-centroid&quot;</span>)</span></code></pre></div>
<pre><code>## png 
##   2</code></pre>
<p>El <a href="Unidad-III/Responses-centroid.pdf">archivo de gráficas</a> que produce <code>plotQuantIntens</code> muestra en cada panel:</p>
<ol style="list-style-type: decimal">
<li><p>La variable analizada con el número de puntos en cada región de valores especificada por el argumento <code>noCuts</code> o número de cortes</p></li>
<li><p>La variable analizada con el proceso de puntos sobrepuesto</p></li>
<li><p>La respuesta de la intensidad de puntos a la variable analizada. En el eje de las <span class="math inline">\(x\)</span> (horizontal), el valor de la variable, y en el eje de las <span class="math inline">\(y\)</span> (vertical) la intensidad (número) de puntos.</p></li>
</ol>
<p>La idea de este análisis es que podamos identificar <em>a priori</em> qué variables podemos incluir en el modelo y con qué tipo de relación. Por ejemplo, las variables 2 y 3 tienen respuestas claramente con forma de parábola invertida o de campana con uno que otro “tope”, por lo que podemos utilizar una fórmula polinomial de <span class="math inline">\(2^o\)</span> grado (figura <a href="unidad-ii---utilizando-spatstat.html#fig:Cuadratica">5.7</a>). Para la variable 1, sin embargo parece haber una región hacia el extremo derecho del eje <span class="math inline">\(x\)</span> en la cual la intensidad vuelve a incrementar. Dado la intensidad de puntos tiende a aumentar nuevamente podríamos utilizar un término cúbico, pues una ecuación cúbica puede adquirir esta forma (figura <a href="unidad-ii---utilizando-spatstat.html#fig:Cubica">5.8</a>).</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="unidad-ii---utilizando-spatstat.html#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(<span class="fu">exp</span>(<span class="dv">1</span> <span class="sc">+</span> x <span class="sc">-</span> x<span class="sc">^</span><span class="dv">2</span>), <span class="at">from =</span> <span class="sc">-</span><span class="dv">3</span>, <span class="dv">3</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Cuadratica"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/Cuadratica-1.png" alt="Ecuación polinomial de 2o grado exponenciada." width="480" />
<p class="caption">
Figura 5.7: Ecuación polinomial de 2o grado exponenciada.
</p>
</div>
<p>Por otro lado, una ecuación polinomial de <span class="math inline">\(3^{er}\)</span> grado:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="unidad-ii---utilizando-spatstat.html#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curve</span>(<span class="fu">exp</span>(<span class="dv">1</span><span class="sc">+</span> x <span class="sc">-</span> <span class="dv">2</span><span class="sc">*</span>x<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> x<span class="sc">^</span><span class="dv">3</span>), <span class="at">from =</span> <span class="sc">-</span><span class="fl">1.5</span>, <span class="at">to =</span> <span class="fl">1.4</span> )</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Cubica"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/Cubica-1.png" alt="Ecuación polinomial de 3er grado exponenciada." width="480" />
<p class="caption">
Figura 5.8: Ecuación polinomial de 3er grado exponenciada.
</p>
</div>
</div>
</div>
<div id="midiendo-la-correlación-entre-variables-independientes" class="section level3 hasAnchor" number="5.1.3">
<h3><span class="header-section-number">5.1.3</span> Midiendo la correlación entre variables independientes<a href="unidad-ii---utilizando-spatstat.html#midiendo-la-correlación-entre-variables-independientes" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Cuando hacemos un análisis de regresión, en deseable que todas las variables independientes que incluyamos en un modelo sean ortogonales, es decir que no estén correlacionadas, que no sean predictoras una de otra. Al incluir variables independientes correlacionadas creamos un problema en el que no es posible medir la varianzade la variable dependiente que explican. Un ejemplo análogo en ANOVA, sería un experimento de dos factores con dos niveles cada uno, y por lo tanto para poder entender el efecto de cada factor con sus niveles necesitaríamos cuatro unidades experimentales como mínimo, 2 niveles del factor I <span class="math inline">\(\times\)</span> 2 niveles del factor II. Si los factores fueran colineales, implicaría que sólo tendríamos por ejemplo, nivel <span class="math inline">\(A\)</span> del factor I con nivel <span class="math inline">\(a\)</span> del factor II, y nivel <span class="math inline">\(b\)</span> del factor I con nivel <span class="math inline">\(b\)</span> del factor II, siendo que requerimos de las combinaciones:<span class="math inline">\(Aa, Ab, Ba\)</span> y <span class="math inline">\(Bb\)</span>.</p>
<p>Para medir la correlación entre pares de variables raster estimamos el coeficiente de correlación de Pearson, con la función <code>pairs</code> del paquete <code>raster</code>. Esta función compara todas las posibles combinaciones de pares de variables en el stack y produce un gráfico de dispersión para cada combinación:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="unidad-ii---utilizando-spatstat.html#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(s)</span></code></pre></div>
<pre><code>## Warning in graphics::par(usr): argument 1 does not name a graphical parameter

## Warning in graphics::par(usr): argument 1 does not name a graphical parameter

## Warning in graphics::par(usr): argument 1 does not name a graphical parameter

## Warning in graphics::par(usr): argument 1 does not name a graphical parameter

## Warning in graphics::par(usr): argument 1 does not name a graphical parameter

## Warning in graphics::par(usr): argument 1 does not name a graphical parameter</code></pre>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:correl"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/correl-1.png" alt="Prueba de correlación para todos los pares de variables." width="672" />
<p class="caption">
Figura 5.9: Prueba de correlación para todos los pares de variables.
</p>
</div>
<p>Como podemos ver, de las variables propuestas sólo podemos utilizar dos de ellas en el mismo modelo, puesto que <code>Var.1</code>y <code>Var.2</code> están correlacionadas. La correlación entre ellas es lineal, como puede verse en el gráfico de dispersión (1a columna 2a fila).</p>
<p>No hay una regla que indique qué coeficiente de correlación es aceptable para incluir en un mismo modelo, sin embargo, mientras más cercano a <span class="math inline">\(0\)</span> y lejos de <span class="math inline">\(1\)</span> ó <span class="math inline">\(-1\)</span> es mejor. Ciertamente <span class="math inline">\(0.76\)</span>, puede ser considerada como alta correlación. Como regla general personal, si el número de variables con respuestas claras observadas con <code>plotQuantIntens</code> alto, podemos utilizar todas aquellas con <span class="math inline">\(r &lt; 0.5\)</span>, si el número de variables es pequeño podemos permitirnos un poco más de libertad e incluir en un mismo modelo todas aquellas con <span class="math inline">\(r \leq 0.7\)</span>.</p>
</div>
<div id="propuesta-de-modelos-alternativos" class="section level3 hasAnchor" number="5.1.4">
<h3><span class="header-section-number">5.1.4</span> Propuesta de modelos alternativos<a href="unidad-ii---utilizando-spatstat.html#propuesta-de-modelos-alternativos" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Anteriormente vimos que la intensidad de puntos (figura <a href="#fig:puntos"><strong>??</strong></a>) tiene una clara res puesta de campana en relación a <code>Var.2</code> y <code>Var.3</code>, y posiblemente <code>Var.1</code>. Por ello podemos proponer una serie de funciones polinomiales de 2o grado donde sólo estén presentes <code>Var.1</code> y <code>Var.3</code>, y <code>Var.2</code> y <code>Var.3</code>. Recordemos que con base en el análisis de correlación no debemos incluir a <code>Var.1</code> y <code>Var.2</code> en el mismo modelo (figura <a href="unidad-ii---utilizando-spatstat.html#fig:correl">5.9</a>). De modo que, en sintaxis de <strong>R</strong>, las fórmulas propuestas del modelo (incluyendo una de 3er grado para <code>Var.1</code>):</p>
<ol style="list-style-type: decimal">
<li><code>~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2)</code></li>
<li><code>~ Var.1 + Var.3 + I(Var.1^2) + I(Var.1^3) + I(Var.3^2)</code></li>
<li><code>~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2)</code></li>
</ol>
<p>La decisión de cuál de las fórmulas propuestas será la final con que trabajaremos, es material del próximo capítulo, por el momento veremos cómo se ajusta un <code>ppm</code>.</p>
</div>
</div>
<div id="ajustando-un-proceso-de-puntos" class="section level2 hasAnchor" number="5.2">
<h2><span class="header-section-number">5.2</span> Ajustando un proceso de puntos<a href="unidad-ii---utilizando-spatstat.html#ajustando-un-proceso-de-puntos" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Aquí veremos cómo se ajusta un proceso de puntos. Como vimos en el capítulo anterior, los datos que analizamos consisten de la intensidad de puntos por unidad espacial, como función de un conjunto de predictores.</p>
<p>Los modelos que ajustaremos son aquellos que propusimos como producto del análisis exploratorio del capítulo anterior. Para ajustar un proceso de puntos Poisson, utilizamos la función <code>ppm</code> (por “point process model”) del paquete <code>spatstat</code>. Los argumentos que debemos incluir al llamar a la función son:</p>
<ol style="list-style-type: decimal">
<li>El objeto que contiene el proceso de puntos</li>
<li><code>trend</code> que corresponde a la fórmula del modelo</li>
<li>La lista de imágenes de pixeles que contiene las covariables que se utilizan en la fórmula (con los mismos nombres)</li>
</ol>
<p>Para ajustar el modelo propuesto con la 1a fórmula propuesta tenemos:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="unidad-ii---utilizando-spatstat.html#cb71-1" aria-hidden="true" tabindex="-1"></a>m1 <span class="ot">&lt;-</span> <span class="fu">ppm</span>(<span class="at">Q =</span> puntos.<span class="fl">2.</span>ppp,</span>
<span id="cb71-2"><a href="unidad-ii---utilizando-spatstat.html#cb71-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">trend =</span> <span class="sc">~</span> Var<span class="fl">.1</span> <span class="sc">+</span> Var<span class="fl">.3</span> <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.1</span><span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.3</span><span class="sc">^</span><span class="dv">2</span>),</span>
<span id="cb71-3"><a href="unidad-ii---utilizando-spatstat.html#cb71-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">covariates =</span> s.im)</span></code></pre></div>
<p>Para ver un resumen detallado del modelo ajustado, podemos utilizar la función <code>summary</code> del objeto creado <code>m1</code>, lo que imprimirá una tabla que muestra los coeficientes estimados, error para cada coeficiente, su significancia y otra información sobre el llamado a la función <code>ppm</code> y estadísticas de convergencia:</p>
<pre><code>## Point process model
## Fitting method: maximum likelihood (Berman-Turner approximation)
## Model was fitted using glm()
## Algorithm converged
## Call:
## ppm.ppp(Q = puntos.2.ppp, trend = ~Var.1 + Var.3 + I(Var.1^2) + 
##     I(Var.3^2), covariates = s.im)
## Edge correction: &quot;border&quot;
##  [border correction distance r = 0 ]
## --------------------------------------------------------------------------------
## Quadrature scheme (Berman-Turner) = data + dummy + weights
## 
## Data pattern:
## Planar point pattern:  200 points
## Average intensity 8.57 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## 
## Dummy quadrature points:
##      32 x 32 grid of dummy points, plus 4 corner points
##      dummy spacing: 0.1562500 x 0.1458333 units
## 
## Original dummy parameters: =
## Planar point pattern:  1028 points
## Average intensity 44.1 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## Quadrature weights:
##      (counting weights based on 32 x 32 array of rectangular tiles)
## All weights:
##  range: [0.0076, 0.0228] total: 23.3
## Weights on data points:
##  range: [0.0076, 0.0114] total: 2.21
## Weights on dummy points:
##  range: [0.0076, 0.0228] total: 21.1
## --------------------------------------------------------------------------------
## FITTED MODEL:
## 
## Nonstationary Poisson process
## 
## ---- Intensity: ----
## 
## Log intensity: ~Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2)
## Model depends on external covariates &#39;Var.1&#39; and &#39;Var.3&#39;
## Covariates provided:
##  Var.1: im
##  Var.2: im
##  Var.3: im
## 
## Fitted trend coefficients:
##   (Intercept)         Var.1         Var.3    I(Var.1^2)    I(Var.3^2) 
## -5.708681e+01  4.649718e-01  1.973027e-01 -1.195420e-03 -6.753759e-04 
## 
##                  Estimate         S.E.       CI95.lo       CI95.hi Ztest
## (Intercept) -5.708681e+01 1.618153e+01 -88.802039552 -2.537159e+01   ***
## Var.1        4.649718e-01 1.498312e-01   0.171308062  7.586355e-01    **
## Var.3        1.973027e-01 9.701636e-02   0.007154105  3.874513e-01     *
## I(Var.1^2)  -1.195420e-03 3.794566e-04  -0.001939142 -4.516991e-04    **
## I(Var.3^2)  -6.753759e-04 3.126318e-04  -0.001288123 -6.262874e-05     *
##                  Zval
## (Intercept) -3.527899
## Var.1        3.103304
## Var.3        2.033705
## I(Var.1^2)  -3.150348
## I(Var.3^2)  -2.160291
## 
## ----------- gory details -----
## 
## Fitted regular parameters (theta):
##   (Intercept)         Var.1         Var.3    I(Var.1^2)    I(Var.3^2) 
## -5.708681e+01  4.649718e-01  1.973027e-01 -1.195420e-03 -6.753759e-04 
## 
## Fitted exp(theta):
##  (Intercept)        Var.1        Var.3   I(Var.1^2)   I(Var.3^2) 
## 1.612543e-25 1.591969e+00 1.218113e+00 9.988053e-01 9.993249e-01</code></pre>
<p>La parte del resumen del modelo ajustado que contiene los detalles de los coeficientes estimados es la que dice <code>Fitted trend coefficients</code>. La primera columna de esta tabla contiene los nombres de las variables, la segunda columna (<code>Estimates</code>) contiene el valor medio estimado de cada coeficiente. Las columnas 3-5 contienen el error estándar (<code>S.E.</code>), intervalo de confianza inferior y superior. La última columna (<code>Ztest</code>) contiene el valor de la probabilidad de que el intervalo a 95% contenga el valor de cero (0). Cuanto menos probable sea que contenga cero mejor.</p>
<p>Las predicciones del modelo podemos verlas con la función <code>plot</code>:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="unidad-ii---utilizando-spatstat.html#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb73-2"><a href="unidad-ii---utilizando-spatstat.html#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(m1)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:unnamed-chunk-64"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/unnamed-chunk-64-1.png" alt="Mapa de las predicciones del modelo. El panel izquierdo muestra la tendencia espacial y el derecho el error estándar de la tendencia estimada." width="768" />
<p class="caption">
Figura 5.10: Mapa de las predicciones del modelo. El panel izquierdo muestra la tendencia espacial y el derecho el error estándar de la tendencia estimada.
</p>
</div>
<div id="selección-del-modelo" class="section level3 hasAnchor" number="5.2.1">
<h3><span class="header-section-number">5.2.1</span> Selección del modelo<a href="unidad-ii---utilizando-spatstat.html#selección-del-modelo" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Ahora que ya sabemos ajustar un modelo, podemos proceder a ajustar los modelos de las fórmulas alternativas:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="unidad-ii---utilizando-spatstat.html#cb74-1" aria-hidden="true" tabindex="-1"></a>m2 <span class="ot">&lt;-</span> <span class="fu">ppm</span>(<span class="at">Q =</span> puntos.<span class="fl">2.</span>ppp,</span>
<span id="cb74-2"><a href="unidad-ii---utilizando-spatstat.html#cb74-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">trend =</span> <span class="sc">~</span> Var<span class="fl">.1</span> <span class="sc">+</span> Var<span class="fl">.3</span> <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.1</span><span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.1</span><span class="sc">^</span><span class="dv">3</span>) <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.3</span><span class="sc">^</span><span class="dv">2</span>),</span>
<span id="cb74-3"><a href="unidad-ii---utilizando-spatstat.html#cb74-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">covariates =</span> s.im)</span>
<span id="cb74-4"><a href="unidad-ii---utilizando-spatstat.html#cb74-4" aria-hidden="true" tabindex="-1"></a>m3 <span class="ot">&lt;-</span> <span class="fu">ppm</span>(<span class="at">Q =</span> puntos.<span class="fl">2.</span>ppp,</span>
<span id="cb74-5"><a href="unidad-ii---utilizando-spatstat.html#cb74-5" aria-hidden="true" tabindex="-1"></a>          <span class="at">trend =</span> <span class="sc">~</span> Var<span class="fl">.2</span> <span class="sc">+</span> Var<span class="fl">.3</span> <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.2</span><span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">I</span>(Var<span class="fl">.3</span><span class="sc">^</span><span class="dv">2</span>),</span>
<span id="cb74-6"><a href="unidad-ii---utilizando-spatstat.html#cb74-6" aria-hidden="true" tabindex="-1"></a>          <span class="at">covariates =</span> s.im)</span></code></pre></div>
<p>El dilema con el que nos enfrentamos ahora es decidir con cuál modelo nos quedaremos. Hay una serie de criterios para tomar esta decisión que tienen que ver principalmente con:</p>
<ol style="list-style-type: decimal">
<li>El cumplimiento de los supuestos estadísticos (independencia de puntos y análisis de residuales)</li>
<li>El balance entre complejidad (cantidad de variables) y varianza explicada</li>
<li>Estimación correcta de los efectos (coeficientes) y su significancia</li>
</ol>
<p>Como vimos anteriormente, el primer supuesto es que los puntos deben ser independientes, por lo que podemos simular envolturas de Ripley para los modelos ajustados, y los residuales podemos analizarlos visualmente. El balance entre la complejidad y la varianza explicada podemos calcularlo con el criterio de información de Akaike.</p>
<div id="criterio-de-información-de-akaike" class="section level4 hasAnchor" number="5.2.1.1">
<h4><span class="header-section-number">5.2.1.1</span> Criterio de información de Akaike<a href="unidad-ii---utilizando-spatstat.html#criterio-de-información-de-akaike" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Calcular el AIC (por sus siglas en inglés), es muy fácil en R. Solamente necesitamos la función <code>AIC</code>, y proporcionarle los modelos cuyos criterios querramos conocer:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="unidad-ii---utilizando-spatstat.html#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(m1)</span></code></pre></div>
<pre><code>## [1] -473.2666</code></pre>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="unidad-ii---utilizando-spatstat.html#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(m2)</span></code></pre></div>
<pre><code>## [1] -473.0841</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="unidad-ii---utilizando-spatstat.html#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(m3)</span></code></pre></div>
<pre><code>## [1] -468.7745</code></pre>
<p>La regla general es que cuanto más bajo sea el AIC, mejor, por lo que el modelo 3 (<code>m3</code>), parece tener la ventaja sobre el 1 y 2.</p>
</div>
<div id="estimación-correcta-de-efectos" class="section level4 hasAnchor" number="5.2.1.2">
<h4><span class="header-section-number">5.2.1.2</span> Estimación correcta de efectos<a href="unidad-ii---utilizando-spatstat.html#estimación-correcta-de-efectos" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Dado que los MPPs son complejos es frecuente encontrarse con modelos que no pudieron ser ajustados correctamente, o sea que la rutina de optimización pudo encontrar los valores de los parámetros y calcular su significancia estadística. Por otra parte, cuando los efectos estadísticos pudieron ser calculados, nos interesa que la mayoría de estos sean significativamente diferentes de cero (<span class="math inline">\(P \leq 0.05\)</span>)</p>
<p>Si revisamos el resumen del modelo <code>m2</code>, veremos que aparecen algunos de los errores mencionados, y que resultan en la ausencia de estimaciones de significancia estadística (columna <code>Ztest</code>).</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="unidad-ii---utilizando-spatstat.html#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m2)</span></code></pre></div>
<pre><code>## Error in solve.default(M) : 
##   sistema es computacionalmente singular: número de condición recíproco = 1.96602e-20</code></pre>
<pre><code>## Warning: Cannot compute variance: Fisher information matrix is singular</code></pre>
<pre><code>## Error in solve.default(M) : 
##   sistema es computacionalmente singular: número de condición recíproco = 1.96602e-20</code></pre>
<pre><code>## Warning: Cannot compute variance: Fisher information matrix is singular</code></pre>
<pre><code>## Point process model
## Fitting method: maximum likelihood (Berman-Turner approximation)
## Model was fitted using glm()
## Algorithm converged
## Call:
## ppm.ppp(Q = puntos.2.ppp, trend = ~Var.1 + Var.3 + I(Var.1^2) + 
##     I(Var.1^3) + I(Var.3^2), covariates = s.im)
## Edge correction: &quot;border&quot;
##  [border correction distance r = 0 ]
## --------------------------------------------------------------------------------
## Quadrature scheme (Berman-Turner) = data + dummy + weights
## 
## Data pattern:
## Planar point pattern:  200 points
## Average intensity 8.57 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## 
## Dummy quadrature points:
##      32 x 32 grid of dummy points, plus 4 corner points
##      dummy spacing: 0.1562500 x 0.1458333 units
## 
## Original dummy parameters: =
## Planar point pattern:  1028 points
## Average intensity 44.1 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## Quadrature weights:
##      (counting weights based on 32 x 32 array of rectangular tiles)
## All weights:
##  range: [0.0076, 0.0228] total: 23.3
## Weights on data points:
##  range: [0.0076, 0.0114] total: 2.21
## Weights on dummy points:
##  range: [0.0076, 0.0228] total: 21.1
## --------------------------------------------------------------------------------
## FITTED MODEL:
## 
## Nonstationary Poisson process
## 
## ---- Intensity: ----
## 
## Log intensity: ~Var.1 + Var.3 + I(Var.1^2) + I(Var.1^3) + I(Var.3^2)
## Model depends on external covariates &#39;Var.1&#39; and &#39;Var.3&#39;
## Covariates provided:
##  Var.1: im
##  Var.2: im
##  Var.3: im
## 
## Fitted trend coefficients:
##   (Intercept)         Var.1         Var.3    I(Var.1^2)    I(Var.1^3) 
## 61.1040359825 -1.3794197996  0.2021579948  0.0083312712 -0.0000163403 
##    I(Var.3^2) 
## -0.0006905730 
## 
## ----------- gory details -----
## 
## Fitted regular parameters (theta):
##   (Intercept)         Var.1         Var.3    I(Var.1^2)    I(Var.1^3) 
## 61.1040359825 -1.3794197996  0.2021579948  0.0083312712 -0.0000163403 
##    I(Var.3^2) 
## -0.0006905730 
## 
## Fitted exp(theta):
##  (Intercept)        Var.1        Var.3   I(Var.1^2)   I(Var.1^3)   I(Var.3^2) 
## 3.444654e+26 2.517246e-01 1.224041e+00 1.008366e+00 9.999837e-01 9.993097e-01</code></pre>
<p>En comparación, el resumen del modelo 3:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="unidad-ii---utilizando-spatstat.html#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m3)</span></code></pre></div>
<pre><code>## Point process model
## Fitting method: maximum likelihood (Berman-Turner approximation)
## Model was fitted using glm()
## Algorithm converged
## Call:
## ppm.ppp(Q = puntos.2.ppp, trend = ~Var.2 + Var.3 + I(Var.2^2) + 
##     I(Var.3^2), covariates = s.im)
## Edge correction: &quot;border&quot;
##  [border correction distance r = 0 ]
## --------------------------------------------------------------------------------
## Quadrature scheme (Berman-Turner) = data + dummy + weights
## 
## Data pattern:
## Planar point pattern:  200 points
## Average intensity 8.57 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## 
## Dummy quadrature points:
##      32 x 32 grid of dummy points, plus 4 corner points
##      dummy spacing: 0.1562500 x 0.1458333 units
## 
## Original dummy parameters: =
## Planar point pattern:  1028 points
## Average intensity 44.1 points per square unit
## binary image mask
## 28 x 30 pixel array (ny, nx)
## pixel size: 0.167 by 0.167 units
## enclosing rectangle: [-104.92138, -99.92138] x [25.355693, 30.02236] units
##                      (5 x 4.667 units)
## Window area = 23.3333 square units
## Fraction of frame area: 1
## Quadrature weights:
##      (counting weights based on 32 x 32 array of rectangular tiles)
## All weights:
##  range: [0.0076, 0.0228] total: 23.3
## Weights on data points:
##  range: [0.0076, 0.0114] total: 2.21
## Weights on dummy points:
##  range: [0.0076, 0.0228] total: 21.1
## --------------------------------------------------------------------------------
## FITTED MODEL:
## 
## Nonstationary Poisson process
## 
## ---- Intensity: ----
## 
## Log intensity: ~Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2)
## Model depends on external covariates &#39;Var.2&#39; and &#39;Var.3&#39;
## Covariates provided:
##  Var.1: im
##  Var.2: im
##  Var.3: im
## 
## Fitted trend coefficients:
##   (Intercept)         Var.2         Var.3    I(Var.2^2)    I(Var.3^2) 
## -3.268417e+01  2.686269e-01  2.552085e-01 -1.146632e-03 -8.348829e-04 
## 
##                  Estimate         S.E.       CI95.lo       CI95.hi Ztest
## (Intercept) -3.268417e+01 1.004036e+01 -52.362919381 -1.300542e+01    **
## Var.2        2.686269e-01 9.339775e-02   0.085570710  4.516832e-01    **
## Var.3        2.552085e-01 9.942583e-02   0.060337421  4.500795e-01     *
## I(Var.2^2)  -1.146632e-03 3.973600e-04  -0.001925444 -3.678210e-04    **
## I(Var.3^2)  -8.348829e-04 3.187065e-04  -0.001459536 -2.102297e-04    **
##                  Zval
## (Intercept) -3.255278
## Var.2        2.876161
## Var.3        2.566823
## I(Var.2^2)  -2.885626
## I(Var.3^2)  -2.619598
## 
## ----------- gory details -----
## 
## Fitted regular parameters (theta):
##   (Intercept)         Var.2         Var.3    I(Var.2^2)    I(Var.3^2) 
## -3.268417e+01  2.686269e-01  2.552085e-01 -1.146632e-03 -8.348829e-04 
## 
## Fitted exp(theta):
##  (Intercept)        Var.2        Var.3   I(Var.2^2)   I(Var.3^2) 
## 6.389180e-15 1.308167e+00 1.290731e+00 9.988540e-01 9.991655e-01</code></pre>
<p>No tiene alertas de errores y sí imprime la columna de significancia estadística. Con esta simple verificación concluimos que <code>m3</code> es más adecuado que <code>m1</code> y <code>m2</code>, con base en los criterios:</p>
<ol style="list-style-type: decimal">
<li>Minimización de AIC</li>
<li>Estimación de efectos</li>
<li>Estimación de significancia estadística</li>
</ol>
<p>Aún así, es posible que <code>m1</code> cumpla mejor con el criterio del supuesto de independencia, que veremos a continuación.</p>
</div>
</div>
<div id="verificación-de-supuestos-de-independencia" class="section level3 hasAnchor" number="5.2.2">
<h3><span class="header-section-number">5.2.2</span> Verificación de supuestos de independencia<a href="unidad-ii---utilizando-spatstat.html#verificación-de-supuestos-de-independencia" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Este criterio lo podemos verificar con dos pruebas adicionales:</p>
<ol style="list-style-type: decimal">
<li>Análisis de residuales</li>
<li>Simulación de envolturas <em>K</em></li>
</ol>
<div id="analisis-de-residuales" class="section level4 hasAnchor" number="5.2.2.1">
<h4><span class="header-section-number">5.2.2.1</span> Analisis de residuales<a href="unidad-ii---utilizando-spatstat.html#analisis-de-residuales" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>En las metodologias de regresion los efectos fijos se utilizan para explicar el comportamiento promedio de una variable aleatoria. Cuando la variable aleatoria tiene una distribucion normal y calculamos la media aritmetica:</p>
<p><span class="math display">\[\begin{equation}
\mu_X = \sum \frac{x_i}{n}
\end{equation}\]</span></p>
<p>y despues restamos la media aritmetica a cada uno de los valores de <span class="math inline">\(X\)</span>, el resultado es la misma variable con distribucion normal pero con media de cero. Para ilustrar esto, simulemos una variable de diez valores con media de 5 y desviacion estandar de 2:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="unidad-ii---utilizando-spatstat.html#cb89-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10</span>, <span class="at">mean =</span> <span class="dv">5</span>, <span class="at">sd =</span> <span class="dv">2</span>); x</span></code></pre></div>
<pre><code>##  [1] 7.2202528 6.1047589 4.3691186 0.9106072 4.4739299 4.6441368 7.2534409
##  [8] 3.5502655 4.4711294 9.7822805</code></pre>
<p>verificamos la media:</p>
<pre><code>## [1] 5.277992</code></pre>
<p>Para mostrar la distribucion de la variable tambien la podemos graficar e indicar donde queda la media estimada:</p>
<p><img src="Mod-nich-distr-MPPs_files/figure-html/unnamed-chunk-71-1.png" width="384" /></p>
<p>El efecto de restar la media a todos los valores de <span class="math inline">\(x\)</span> se muestra a continuacion</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="unidad-ii---utilizando-spatstat.html#cb92-1" aria-hidden="true" tabindex="-1"></a>x<span class="fl">.0</span> <span class="ot">&lt;-</span> x <span class="sc">-</span> <span class="fu">mean</span>(x)</span>
<span id="cb92-2"><a href="unidad-ii---utilizando-spatstat.html#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(x<span class="fl">.0</span>), <span class="at">col =</span> <span class="st">&quot;red&quot;</span>, <span class="at">main =</span> <span class="st">&quot;Densidad de x.0&quot;</span>)</span>
<span id="cb92-3"><a href="unidad-ii---utilizando-spatstat.html#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="fu">mean</span>(x<span class="fl">.0</span>), <span class="at">lty =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="Mod-nich-distr-MPPs_files/figure-html/normal-cent-1.png" width="384" /></p>
<p>Para mostrar mas objetivamente que ambas variables tienen una distribucion normal tambien podemos hacer:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="unidad-ii---utilizando-spatstat.html#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="fu">shapiro.test</span>(x)</span></code></pre></div>
<pre><code>## 
##  Shapiro-Wilk normality test
## 
## data:  x
## W = 0.95411, p-value = 0.7171</code></pre>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="unidad-ii---utilizando-spatstat.html#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">shapiro.test</span>(x<span class="fl">.0</span>)</span></code></pre></div>
<pre><code>## 
##  Shapiro-Wilk normality test
## 
## data:  x.0
## W = 0.95411, p-value = 0.7171</code></pre>
<p>De igual manera que como acabamos de hacer al restar la media de toda la variable <span class="math inline">\(x\)</span> los residuals se obtienen restando las predicciones de un modelo (lineal o de puntos, p. ej.) se restan a todos los valores de la variable dependiente. Por ejemplo, vamos a simular otras dos variables <span class="math inline">\(x\)</span> y <span class="math inline">\(y\)</span>, de modo que:</p>
<p><span class="math display">\[ y(x) = \alpha + \beta x\]</span>
<span class="math inline">\(y\)</span> sea una funcion de <span class="math inline">\(x\)</span>.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="unidad-ii---utilizando-spatstat.html#cb97-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span>)</span>
<span id="cb97-2"><a href="unidad-ii---utilizando-spatstat.html#cb97-2" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">100</span>, <span class="dv">10</span>, <span class="dv">1</span>) <span class="sc">+</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>) <span class="sc">*</span> x</span>
<span id="cb97-3"><a href="unidad-ii---utilizando-spatstat.html#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x, y, <span class="at">main =</span> <span class="st">&quot;&quot;</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="Mod-nich-distr-MPPs_files/figure-html/unnamed-chunk-73-1.png" width="384" /></p>
<p>Ajustaremos el modelo lineal para estimar a <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(\beta\)</span>, y extraer los residuales:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="unidad-ii---utilizando-spatstat.html#cb98-1" aria-hidden="true" tabindex="-1"></a>mod.lin <span class="ot">&lt;-</span> <span class="fu">lm</span>(y<span class="sc">~</span>x)</span>
<span id="cb98-2"><a href="unidad-ii---utilizando-spatstat.html#cb98-2" aria-hidden="true" tabindex="-1"></a>resids <span class="ot">&lt;-</span> <span class="fu">residuals</span>(mod.lin)</span>
<span id="cb98-3"><a href="unidad-ii---utilizando-spatstat.html#cb98-3" aria-hidden="true" tabindex="-1"></a>predics <span class="ot">&lt;-</span> <span class="fu">predict</span>(mod.lin)</span></code></pre></div>
<p>y veremos como <span class="math inline">\(\varepsilon = y - y(x)\)</span></p>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="unidad-ii---utilizando-spatstat.html#cb99-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">y =</span> y, <span class="at">predicciones =</span> predics, <span class="at">residuales =</span> resids)</span>
<span id="cb99-2"><a href="unidad-ii---utilizando-spatstat.html#cb99-2" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="fu">head</span>(df))</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">y</th>
<th align="right">predicciones</th>
<th align="right">residuales</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">9.547765</td>
<td align="right">9.873913</td>
<td align="right">-0.3261483</td>
</tr>
<tr class="even">
<td align="right">10.919382</td>
<td align="right">11.475169</td>
<td align="right">-0.5557877</td>
</tr>
<tr class="odd">
<td align="right">10.862230</td>
<td align="right">10.278643</td>
<td align="right">0.5835869</td>
</tr>
<tr class="even">
<td align="right">10.403145</td>
<td align="right">11.145252</td>
<td align="right">-0.7421070</td>
</tr>
<tr class="odd">
<td align="right">6.016042</td>
<td align="right">6.419692</td>
<td align="right">-0.4036495</td>
</tr>
<tr class="even">
<td align="right">10.533279</td>
<td align="right">10.254839</td>
<td align="right">0.2784400</td>
</tr>
</tbody>
</table>
<p>puesto que <span class="math inline">\(y(x_i)\)</span> es la media de <span class="math inline">\(y_i\)</span> para <span class="math inline">\(x_i\)</span>. De modo que del mismo modo que con la figura <a href="#fig:normal-cent"><strong>??</strong></a>, los residuales <span class="math inline">\(\varepsilon\)</span> tienen una distribucion normal con media de cero (0):</p>
<p><img src="Mod-nich-distr-MPPs_files/figure-html/unnamed-chunk-76-1.png" width="384" /></p>
<p>En el caso de los procesos de puntos los residuales tambien deben tener una media de cero, y ser aproximadamente normales (con varianza homogenea).</p>
<p>A diferencia de los procedimientos de regresión lineal, los procesos de puntos no se limitan al análisis de las coordenadas del fenómeno que estamos estudiando, si no a todas las unidades espaciales donde podría estar definido el proceso de puntos. Esto implica que tenemos que evaluar los residuales en el espacio. aquí surge una pregunta muy natural, ¿cómo se evalúan los residuales de una serie de puntos discretos en una rejilla de unidades espaciales? El paquete <code>spatstat</code> emplea un método muy ingenioso que consiste en:</p>
<ol style="list-style-type: decimal">
<li>Generación de un mapa de densidad del procesos de puntos analizado con una estimación de kernel</li>
<li>Calcular la diferencia entre la densidad estimada con el modelo y la de kernel</li>
<li>Suavizar la diferencia, promediando unidades espaciales adyacentes con una distancia similar a la utilizada en la estimación de kernel</li>
<li>Sumar los residuales en las dimensiones <span class="math inline">\(x\)</span> y <span class="math inline">\(y\)</span></li>
</ol>
<p>El resultado de este procedimiento se llama <em>lurking plot</em>. La función para hacer este análisis es <code>diagnose.ppm</code>:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="unidad-ii---utilizando-spatstat.html#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb100-2"><a href="unidad-ii---utilizando-spatstat.html#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="fu">diagnose.ppm</span>(m3)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:diag"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/diag-1.png" alt="Gráfico de residuales suavizados del modelo 3." width="480" />
<p class="caption">
Figura 5.11: Gráfico de residuales suavizados del modelo 3.
</p>
</div>
<pre><code>## Model diagnostics (raw residuals)
## Diagnostics available:
##  four-panel plot
##  mark plot 
##  smoothed residual field
##  x cumulative residuals
##  y cumulative residuals
##  sum of all residuals
## sum of raw residuals in entire window = -8.688e-11
## area of entire window = 23.33
## quadrature area = 23.33
## range of smoothed field =  [-4.133, 2.697]</code></pre>
<p>El primer panel (arriba, izquierdo) de este gráfico muestra el proceso de puntos analizado, seguido a la derecha, de los residuales acumulados en el eje de las <span class="math inline">\(y\)</span>. En el panel de abajo a la izquierda se muestran los residuales acumulados en el eje de las <span class="math inline">\(x\)</span> y en el panel de abajo a la derecha, se muestran los residuales. En un escenario ideal, este último panel debe mostrar valores muy cercanos a cero. Las líneas punteadas que rodean a la suma de residuales son los límites de tolerancia que no deben ser excedidos por los residuales para cumplirse el supuesto de aleatoriedad de los residuales. Como resulta evidente, los residuales en <span class="math inline">\(y\)</span> exceden el límite de tolerancia en una región.</p>
</div>
<div id="simulación-de-envolturas-de-ripley" class="section level4 hasAnchor" number="5.2.2.2">
<h4><span class="header-section-number">5.2.2.2</span> Simulación de envolturas de Ripley<a href="unidad-ii---utilizando-spatstat.html#simulación-de-envolturas-de-ripley" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Como vimos en el análisis exloratorio, podemos medir la autocorrelación para ver si de antemano necesitamos tomarla en cuenta para el análisis. La prueba que hicimos fue la de Ripley, comparando el número promedio de vecinos en función de un radio al rededor de cada punto. Aún cuando un proceso de puntos Poisson asume que los puntos son independientes entre sí, es posible que cuando detectamos autocorrelación con la prueba de Ripley, podamos generar un modelo Poisson que explique el patrón de puntos por medio de covariables. Para ver si el modelo que formulamos en efecto explica la autocorrelación, podemos usarlo para simular patrones de puntos y comparalos con la expectativa teórica.</p>
<p>Para hacer esta comparación utilizamos la misma función que antes, pero el primer argumento es el objeto que contiene el modelo que queremos analizar. Comparemos en esta ocasión los tres modelos:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="unidad-ii---utilizando-spatstat.html#cb102-1" aria-hidden="true" tabindex="-1"></a>K1 <span class="ot">&lt;-</span> <span class="fu">envelope</span>(m1, Kest, <span class="at">nsim =</span> <span class="dv">39</span>)</span></code></pre></div>
<pre><code>## Generating 39 simulated realisations of fitted Poisson model  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.
## 
## Done.</code></pre>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="unidad-ii---utilizando-spatstat.html#cb104-1" aria-hidden="true" tabindex="-1"></a>K2 <span class="ot">&lt;-</span> <span class="fu">envelope</span>(m2, Kest, <span class="at">nsim =</span> <span class="dv">39</span>)</span></code></pre></div>
<pre><code>## Generating 39 simulated realisations of fitted Poisson model  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.
## 
## Done.</code></pre>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="unidad-ii---utilizando-spatstat.html#cb106-1" aria-hidden="true" tabindex="-1"></a>K3 <span class="ot">&lt;-</span> <span class="fu">envelope</span>(m3, Kest, <span class="at">nsim =</span> <span class="dv">39</span>)</span></code></pre></div>
<pre><code>## Generating 39 simulated realisations of fitted Poisson model  ...
## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,  39.
## 
## Done.</code></pre>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="unidad-ii---utilizando-spatstat.html#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))</span>
<span id="cb108-2"><a href="unidad-ii---utilizando-spatstat.html#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(K1); <span class="fu">plot</span>(K2); <span class="fu">plot</span>(K3)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:K-modelos"></span>
<img src="Mod-nich-distr-MPPs_files/figure-html/K-modelos-1.png" alt="Gráficas de las envolturas de Ripley." width="1152" />
<p class="caption">
Figura 5.12: Gráficas de las envolturas de Ripley.
</p>
</div>
<p>Todos los modelos muestran un comportamiento adecuado, aunque <code>m3</code> parece estar marginalmente más cerca de la expectativa teórica (en rojo), sin ser significativo.</p>

</div>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="unidad-ii-modelación-de-nichos-ecológicos-con-procesos-de-puntos.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="unidad-iv-modelos-para-procesos-de-puntos-con-estructura-espacial.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Mod-nich-distr-MPPs.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
